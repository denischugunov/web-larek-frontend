# Описание базовых классов

1. Api
Класс Api предоставляет методы для работы с сервером:

get — для выполнения GET-запросов.
post — для отправки данных через POST, PUT или DELETE.
Конструктор:
Принимает:

baseUrl — базовый URL для всех запросов.
options — настройки запросов, включая заголовки по умолчанию (Content-Type: application/json).
Методы:
get(uri) — выполняет GET-запрос по указанному URI.
post(uri, data, method = 'POST') — отправляет данные на сервер с использованием POST, PUT или DELETE.
Оба метода возвращают промис, который при успешном ответе возвращает JSON-объект, а при ошибке — сообщение об ошибке.


2. EventEmitter
Класс EventEmitter реализует механизм брокера событий, используя паттерн Наблюдатель (Observer). Он позволяет объектам подписываться на события и уведомляет их, когда эти события происходят.

При создании объекта класса EventEmitter, конструктор инициализирует объект типа Map, где:

Ключами выступают названия событий (или шаблоны событий),
Значениями — Set (множество) с подписчиками, то есть функциями, которые будут вызываться при возникновении соответствующего события.
Класс реализует интерфейс IEvents и предоставляет следующие основные методы:

on(eventName, callback) — подписывает на событие:

Принимает название события и функцию-обработчик (callback), которая будет вызвана при возникновении этого события. Например, это может быть функция для обновления пользовательского интерфейса.
off(eventName, callback) — отменяет подписку:

Позволяет удалить функцию-обработчик (callback) с определённого события. Если все подписчики удалены, событие также удаляется из списка.
emit(eventName, data) — генерирует событие:

Принимает название события и данные, которые будут переданы подписчикам. Вызывает все функции-обработчики, зарегистрированные на это событие. Аргумент data является опциональным и может отсутствовать.
Дополнительные методы:
onAll(callback) — подписывает функцию на все события. Функция будет вызываться каждый раз, когда происходит любое событие.

offAll() — удаляет всех подписчиков всех событий. Полностью очищает список зарегистрированных событий и обработчиков.

trigger(eventName, context) — создаёт функцию для отложенной генерации события:

Работает как emit, но возвращает функцию, которая генерирует событие при вызове. Это позволяет создавать "триггеры", которые можно использовать позднее для многократной генерации одного и того же события с предустановленными параметрами.

# ************************************************************************************************************

# Компоненты модели данных

# 1. Модель (без класса, только интерфейс) товара

interface IProduct {
  id: string;
  description: string;
  image: string;
  title: string;
  category: Category; // Используем enum для категории
  price: number | null; // Цена может быть числом или null
}

enum Category {
  SoftSkill = "софт-скил",
  HardSkill = "хард-скил",
  Button = "кнопка",
  Another = "другое",
  Additional = "дополнительное",
}

# 2. Модель продуктового листа

interface IProductList {
  total: number; // Общее количество товаров в списке
  items: IProduct[]; // Массив товаров

  // Методы
  getItems(): IProduct[]; // Метод для получения списка товаров
}

# 3. Модель корзины

interface ICartItem {
  count: number; // Количество товаров в корзине
  item: IProduct; // Товар
}

interface ICart {
  total: number; // Итоговая цена корзины
  items: ICartItem[]; // Массив товаров с количеством

  // Методы
  addItem(item: IProduct): void; // Добавляет товар в корзину
  removeItem(itemId: string): void; // Убирает товар из корзины
  getTotalCost(): number; // Получение итоговой цены корзины
  getItemsList(): ICartItem[]; // Получение массива товаров с их количеством для дальнейшей работы с ним в заказе
  getItemCost(itemId: string): number; // Получение цены за товар (цена * количество)
}


# 4. Модель заказа (orderData или orderModel)

type PaymentMethod = "Онлайн" | "При получении";

interface ISendOrderResponse {
  id: string; // Идентификатор заказа
  total: number; // Итоговая сумма заказа
}

interface IOrderData {
  payment: PaymentMethod; // Способ оплаты
  email: string; // Почта клиента
  phone: string; // Телефон клиента
  address: string; // Адрес доставки
  total: number; // Итоговая стоимость заказа
  items: string[]; // Массив ID товаров (как требуется сервером)

  // Методы
  addPayment(payment: string): void; // Добавляет способ оплаты
  addEmail(email: string): void; // Добавляет почту клиента
  addPhone(phone: string): void; // Добавляет телефон клиента
  addAddress(address: string): void; // Добавляет адрес клиента
  setTotal(total: number): void; // Устанавливает итоговую цену заказа
  setItems(items: string[]): void; // Устанавливает массив ID товаров
  sendOrder(): Promise<ISendOrderResponse>; // Отправка заказа
}

# ************************************************************************************************************

# Компоненты представления данных

# 1. Представление карточки товара

interface IProductUI {
  productData: IProduct;
  template: HTMLElement;

  // Методы
  render(): void; // Метод рендеринга, который будет реализован в каждом виде карточки (с разными темплейтами)
}

# Класс ProductUI имплементирует интерфейс IProductUI,
# а наследуют класс ProductUI: ProductСardСatalogUI, ProductCardPreviewUI, ProductCardBasketUI.
# Это нужно для реализации паттерна стратегия, когда класс ProductCardRenderer
# будет отбирать нужную стратегию в зависимости от используемого темплейта

# 2. интерфейс класса, реализующего выбор стратегии, создающего как фабрика нужный объект и метод рендеринга карточки в выбранный контейнер

interface IProductCardRenderer {
  // Методы
  render(container: HTMLElement): void; // Метод для рендеринга карточки в указанный контейнер (он тут, а не в методе карточки для сохранения принципа единой отвественности)
}

# 3. Представление продуктового листа

interface IProductListUI {
  container: HTMLElement; // Контейнер, куда будут отрендерены карточки
  items: IProduct[]; // Массив товаров
  
  // Методы
  render(): void; // Метод рендеринга всех карточек в галерее главной страницы
}

# 4. Представление корзины

interface IBasketUI {
  items: IProduct[];
  template: HTMLElement;

  // Методы
  render(): void; // Метод рендеринга информации о добавленных в корзину карточках
}

# 5. Представление попапов формы оформления заказа

interface IOrderDataUI {
  // Методы
  render(): void; // Метод рендеринга попапа с формой заполнения
}

# На основании интерфейса IOrderDataUI будет создан класс OrderDataUI, который будет наследоваться 
# двумя классами OrderDataOrderUI и OrderDataContactsUI, каждый из них отвечает за свой попап с формой

# В таком случае, интерфейсы для классов конкретных попапов могут выглядеть так:

interface IOrderDataOrderUI extends IOrderDataUI {
    payment: PaymentMethod; // Способ оплаты
    email: string; // Почта клиента
}

interface IOrderDataContactsUI extends IOrderDataUI {
    phone: string; // Телефон клиента
    address: string; // Адрес доставки
}

# 6. Представление попапа удачного оформления заказа

interface ISuccessUI {
  render(): void; // Метод рендеринга попапа с информацией об успешном оформлении заказа
}